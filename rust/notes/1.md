# Chapter 1

# Setup

## Program definition

- main runs always first
- params in ()
- function body in {}
- macro has !
- function is without !
- ; means expression is over.


## Program execution
- first compile
- second you have binary that is executable

## Cargo
- simple programms compile in rustc -> more complicated use Cargo.
    - managing libraries and dependencies
- to create new project: 'cargo new <project_name>'

- Cargo creates .toml (cargo.toml <==> pyproject.toml). (TOML == Toms obvious minimal language)

- To build and compile .toml project run <cargo build>

- To execute/debug the program navidate to /<myproject_name> -> run ./target/debug/<project_name> this executes the code

- No need to use cargo build and path to debug/<prpoject_name> I can just do cargo run.

- To check code but not run it, one can use: <cargo run>

## Commands:
- cargo build
    - builds and compiles programm

- cargo new <project_name>
    - creates Cargo.toml + src folder

- ./target/debug/<module name>
    - after build from cargo build you can debug using this command

- cargo run
    - simpler compiling and running of code by doing those two commands together

- cargo check
    - checks if code compiles
    - much faster
    - use periodically to check if code compiles

- cargo build --release
    - compilation with optimizations.
    - creates executable in target/release instead of target debug

    - releasing speeds up the code, but takes longer hence two different ways to do it